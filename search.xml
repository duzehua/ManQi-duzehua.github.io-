<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Python-SQL Server数据库]]></title>
    <url>%2F2018%2F06%2F21%2FPythonSqlServer%E6%95%B0%E6%8D%AE%E5%BA%93%2F</url>
    <content type="text"><![CDATA[SQL Server 数据库(待完善):导入环境: 12import pymssqlimport adodbapi 建立数据库连接 1234# 方法一conn = adodbapi.connect("Provider=SQLOLEDB; SERVER='IP地址:端口'; Initial Catalog=数据库名称;User Id=sa; Password=密码; ")# 方法二conn = pymssql.connect(host='IP地址:端口', user='sa', password='密码', database='数据库名称', charset='utf8') 使用连接对象获得一个cursor对象 1cursor = conn.cursor() 使用cursor操作数据库操 命令汇总: callproc(self, procname, args): execute(self, query, args): executemany(self, query, args): nextset(self): 12345# 使用示例sql="insert into student values (%s,%s,%s)" # 所有数据类型均用s%param=(1, ManQi,18) # param应为tuple或list# 插入一条数据n=cursor.execute(sql,param) 执行cursor接收操作数据库返回值. 方法汇总: fetchall(self): 接收全部元组. fetchmany(self, size=None): 接收不大于size条返回结果行. fetchone(self): 返回一条元组. scroll(self, value, mode=’relative’): 1result = cursor.fetchall() # result为tuple类型, 其中单条结果也为tuple类型数据, 在对数据库进行增删操作后, 需提交. 否则修改无效. 1conn.commit() 操作结束, 执行关闭操作. 12cursor.close() # 关闭指针对象conn.close() # 关闭连接对象 附, 简单的数据库语句 1234567891011121314151617/*表: student结构: id(int), name(varchar(MAX)), age(varchar(MAX))*/--插入一条数据insert into student values (1,ManQi,18)--返回名为ManQi, 且年龄为空的第一条数据select top 1 id from student where (name = 'ManQi') and (age is null)--更新id为1的名字update student set name = 'TY' where id = 1--即删除字段为某值的所有记录delete from 表名 where 字段=某值 --将表中字段为某值的替换为nullupdate 表名 set 字段=null where 字段=某值 --显示表格所有信息select * from student/*注意到, sql中空为null, python中为none*/]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python-多线程与多进程]]></title>
    <url>%2F2018%2F06%2F21%2FPython%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%A4%9A%E8%BF%9B%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[多线程与多进程:​ python中可方便实现多线程与多进程. 而由于全局解释器锁的存在, 多线程实际为将多个单线程拆分为执行序列, 每个时刻只执行其中一个线程, 因而python中的多线程更适合于IO密集型操作. 为充分利用多核cpu资源, 执行计算密集型操作, 可引用多进程操作. ​ 接下在就工程中涉及到的多线程与多进程应用的数种方法, 示例记录, 便于记忆. 多线程:导入环境 12import timeimport threading 在派生类中重写父类threading.Thread的run()方法. 注意, 子类中只有init()和run()方法被重写. 然后在主线程中生成子线程类的对象, 调用start()方法运行. 123456789101112class MyThread(threading.Thread): def __init__(self): threading.Thread.__init__(self) def run(self): global iterNum, threadLock # 多线程中, 通过定义全局变量实现数据共享 time.sleep(1) if threadLock.acquire(): print(iterNum , self.name) iterNum += 1 threadLock.release() 主程序中创建线程并调用 123456789101112131415161718192021if "__main__" == __name__: start_time = time.time() print('主线程名称：', threading.current_thread().name) iterNum = 1 threadList = [] lock = threading.Lock() # 创建200个线程, 存入list for index in range(5): thread_ = MyThread() threadList.append(index) # 开启线程 for thread_ in ThreadList: # thread_.setDaemon(True) # 设置线程守护 thread_.start() print('主线程: ' + threading.current_thread().name + '结束') print('共计耗时：', time.time()-start_time) 上述代码中, 通过start()方法开启线程. 注意到, 开启线程前存在一个注释掉的守护线程setDaemon(). setDaemon()默认false, 表示主线程执行完任务后会退出, 而子线程继续执行直到任务完成. 该条件下, 结果如下: 12345678910主线程名称： MainThread主线程: MainThread结束共计耗时： 0.00100302696228027341 Thread-42 Thread-13 Thread-54 Thread-25 Thread-3Process finished with exit code 0 接下来, 取消注释, 设置守护线程为true, 代码为: 123456789101112131415161718192021if "__main__" == __name__: start_time = time.time() print('主线程名称：', threading.current_thread().name) iterNum = 1 threadList = [] lock = threading.Lock() # 创建200个线程, 存入list for index in range(5): thread_ = MyThread() threadList.append(index) # 开启线程 for thread_ in ThreadList: thread_.setDaemon(True) # 设置线程守护 thread_.start() print('主线程: ' + threading.current_thread().name + '结束') print('共计耗时：', time.time()-start_time) 结果如下: 12345主线程名称： MainThread主线程: MainThread结束共计耗时： 0.0009665489196777344Process finished with exit code 0 可以看出, 主线程运行结束, 由于守护线程的缘故, 直接将子线程杀死, 不再继续运行. 而部分条件下, 我们需要的结果是当主线程开启, 等待子线程运行结束后, 再结束主线程. 此时, 可以通过使用join()来实现, 代码如下: 123456789101112131415161718192021222324if "__main__" == __name__: start_time = time.time() print('主线程名称：', threading.current_thread().name) iterNum = 1 threadList = [] lock = threading.Lock() # 创建200个线程, 存入list for index in range(5): thread_ = MyThread() threadList.append(index) # 开启线程 for thread_ in ThreadList: thread_.setDaemon(True) # 设置线程守护 thread_.start() for thread_ in ThreadList: thread_.join() print('主线程: ' + threading.current_thread().name + '结束') print('共计耗时：', time.time()-start_time) join()中存在一个timeout参数, 当设置守护线程时, 主线程等待timeout时间后再执行杀死子线程的操作. 当timeout不设定时, 表示等待子线程运行结束后, 再结束主线程. 上述代码运行结果如下: 12345678910主线程名称： MainThread1 Thread-52 Thread-23 Thread-34 Thread-15 Thread-4主线程: MainThread结束共计耗时： 1.006718397140503Process finished with exit code 0 可以看出, 主线程以及计时均等待子线程结束后才开始实现. 当设定timeout时, 以下述两种情况为例: 12345678910111213141516171819202122# 设定 timeout = 0, 则5个子线程共计等待 0 * 5 = 0s, 即主线程不等待直接杀死子线程.for thread_ in ThreadList: thread_.join(0)主线程名称： MainThread主线程: MainThread结束共计耗时： 0.005353212356567383Process finished with exit code 0# 设定 timeout = 0.2, 则5个子线程共计等待 0.2 * 5 = 1s, 主线程等待1s后杀死子线程.for thread_ in ThreadList: thread_.join(0.2)主线程名称： MainThread1 Thread-32 Thread-13 Thread-5主线程: MainThread结束共计耗时： 1.0059242248535156Process finished with exit code 0 可以看出, 当timeout设定为0.2s时, 有三个子线程运行结束, 仍有两个没来得及运行即被杀死. 多进程​ 相对于多线程来说, 多进程操作中, 每一个子进程会作为真正独立的程序运行. 多线程运行过程中, 一个线程异常将导致整个程序故障. 而多进程中, 一个子进程异常基本不会影响其他进程的运行, 因而具有一定的稳定性, 但也较难以调试和控制. 此外, 多进程间的数据传递无法通过设置全局变量实现, 必须通过其专有的队列, 管道或共享内存的方式实现. 导入环境 1import multiprocessing 为防止由于多个子进程导致的系统假死, 在主函数的最开始, 添加如下语句: 1multiprocessing.freeze_support() 启动子进程的几种方法 123456789101112131415# 方法1process1 = multiprocessing.Process(target=processFun1, args=(param,))process2 = multiprocessing.Process(target=processFun2, args=(param,))process1.start()process2.start()# 方法2:pool = multiprocessing.Pool(processes=2) # 创建进程池, 参数可缺省pool.apply_async(processFun1, (param, ))pool.apply_async(processFun2, (param, ))pool.close() # 关闭进程池，表示不能在往进程池中添加进程pool.join() # 含义同多线程join()，必须在close()之后调用 进程间数据共享支持queue, pipi, value和array. 但是python提供的更高层次的封装, 在我觉得使用起来更加方便, 而这些高级接口的调用, 可通过multiprocessing.Manager()方便的进行调用. multiprocessing.Manager()支持list, dict, Namespace, Lock, RLock, Semaphore, BoundedSemaphore, Condition, Event, Queue, Value和Array. 1234multiProcessManager = multiprocessing.Manager()# list定义与调用示例mPMList = multiProcessManager.list([0] * 10)callLlist = mPMList.value]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>多线程</tag>
        <tag>多进程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原来是鸡汤啊~]]></title>
    <url>%2F2018%2F06%2F20%2F%E5%8E%9F%E6%9D%A5%E6%98%AF%E9%B8%A1%E6%B1%A4%E5%95%8A%2F</url>
    <content type="text"><![CDATA[“我不去想是否能够成功, 既然选择了远方, 便只顾风雨兼程”. ——汪国真 “当生活很着急地步入正轨, 然后拿做完事情之余和空闲时间来看点什么的时候, 也是比无所事事玩手机的时候来得真开心”. ——刘佳楠 “要谨记美言不可信, 要善于识别过眼烟云. 不要轻信唯一正确, 不能执着于左右两端, 要做到通而不痛, 远离烦恼, 创新永远”. ——钱旭红]]></content>
      <categories>
        <category>鸡汤</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[机器人学-学习笔记]]></title>
    <url>%2F2018%2F06%2F17%2F%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%AD%A6%2F</url>
    <content type="text"><![CDATA[前言:​ ——距离放下这门课已经差不多一年了, 知识点也已经忘了十有七八. 真是年龄越长, 忘性越大. 遂打算业余时间翻看翻看之前的书籍, 做做笔记. 也不枉学过一番. 基础知识机器人位(置)姿(态) 表示​ 由于需要描述机器人不同部件之间, 以及机器人与外界之间的相对关系(通常指位姿关系), 需用到空间位置矢量, 姿态角等信息. 空间位置​ 通常使用笛卡尔空间坐标系描述相对位置关系, 应用3x1的位置矢量描述空间任意一点的位置. 对笛卡尔坐标系{A}, 空间任意一点p的位置可描述为: {}^Ap = \left[ {\begin{array}{*{20}{c}} {p_x} \\ {p_y} \\ {p_z} \\ \end{array}} \right]$p_x$ , $p_y$ 和$p_z$ 为点p 沿坐标系{A}的x,y,z三个轴线方向的坐标分量. 其中, $^Ap$ 中上标A代表参考坐标系{A}, 称$^Ap$为位置矢量. 姿态描述​ 为完成位姿关系的描述, 除要表示空间位置关系外, 还需要表示物体此时所处姿态(可理解为朝向). 首先直接来看一组姿态表示, 刚体B在坐标系{A} 中的姿态描述: _B^AR = \left[ {\begin{array}{*{20}{c}} {^A{x_B}} & {^A{y_B}} & {^A{z_B}} \\ \end{array}} \right] = \left[ {\begin{array}{*{20}{c}} {r_{11}} & {r_{12}} & {r_{13}} \\ {r_{21}} & {r_{22}} & {r_{23}} \\ {r_{31}} & {r_{32}} & {r_{33}} \\ \end{array}} \right]其中, $_B^AR $表示以坐标系{A}为参考坐标系, 刚体B的姿态表示. 可以理解为假如你是这个刚体, 以大地上某个固定的坐标系为参考坐标系. 你相对于这个坐标系的朝向(姿态), 朝东还是朝西多少度, 朝上还是朝下多少度, 朝南还是朝北多少度. 在此, 以后 参考文献: 机器人学, 蔡自兴 …]]></content>
      <categories>
        <category>机器人</category>
      </categories>
      <tags>
        <tag>机器人学</tag>
        <tag>运动学</tag>
        <tag>动力学</tag>
      </tags>
  </entry>
</search>
