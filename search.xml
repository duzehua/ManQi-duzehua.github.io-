<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>pip清华源官方配置方法</title>
      <link href="/2021/01/12/Pythoh%E9%85%8D%E7%BD%AE%E6%B8%85%E5%8D%8E%E6%BA%90/"/>
      <url>/2021/01/12/Pythoh%E9%85%8D%E7%BD%AE%E6%B8%85%E5%8D%8E%E6%BA%90/</url>
      <content type="html"><![CDATA[<h3 id="官方配置方法："><a href="#官方配置方法：" class="headerlink" title="官方配置方法："></a>官方配置方法：</h3><p>按照官网提示，pip配置清华源的方法如下：</p><h4 id="临时使用"><a href="#临时使用" class="headerlink" title="临时使用"></a>临时使用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install -i https://pypi.tuna.tsinghua.edu.cn/simple some-package</span><br></pre></td></tr></table></figure><p>注意，<code>simple</code> 不能少, 是 <code>https</code> 而不是 <code>http</code></p><h4 id="设为默认"><a href="#设为默认" class="headerlink" title="设为默认"></a>设为默认</h4><p>升级 pip 到最新的版本 (&gt;=10.0.0) 后进行配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install pip -U</span><br><span class="line">pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure><p>如果您到 pip 默认源的网络连接较差，临时使用本镜像站来升级 pip：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install -i https://pypi.tuna.tsinghua.edu.cn/simple pip -U</span><br></pre></td></tr></table></figure><h4 id="报错应对措施"><a href="#报错应对措施" class="headerlink" title="报错应对措施"></a>报错应对措施</h4><p>正常情况下，脚本可成功安装运行。但在某些特殊情况下，运行“pip install pip -U”命令时出现错误，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Could not install packages due to an EnvironmentError: [WinError 5] 拒绝访问。: &apos;X:\\anaconda3\\scripts\\pip.exe&apos;</span><br><span class="line">Consider using the `--user` option or check the permissions.</span><br></pre></td></tr></table></figure><p>再次运行“pip install pip -U”命令，出现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\Administrator&gt;pip install pip -U --user</span><br><span class="line">Script file &apos;D:\Anaconda3\Scripts\pip-script.py&apos; is not present.</span><br></pre></td></tr></table></figure><p>因为使用了 “install -U” 导致pip被自动卸载，无法使用pip实现再次安装。当出现这种错误时，首先切换到anaconda安装路径下的Scripts目录下（即Python的Scripts目录），cmd运行如下命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">easy_install pip</span><br></pre></td></tr></table></figure><p>easy_install和pip均可下载安装PyPI资源包。其中，pip是easy_install的改进版。</p><p>当提示pip安装成功时，再次运行官方配置方法即可。</p>]]></content>
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pip </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python-pip安装报错无法卸载资源的处理方法</title>
      <link href="/2021/01/12/Python-pip%E5%AE%89%E8%A3%85%E6%8A%A5%E9%94%99%E6%97%A0%E6%B3%95%E5%8D%B8%E8%BD%BD%E8%B5%84%E6%BA%90%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95/"/>
      <url>/2021/01/12/Python-pip%E5%AE%89%E8%A3%85%E6%8A%A5%E9%94%99%E6%97%A0%E6%B3%95%E5%8D%B8%E8%BD%BD%E8%B5%84%E6%BA%90%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>在通过pip安装第三方资源包时，由于其可能牵扯到其它第三方包的更新，在某些特殊场景下可能会报错，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ERROR: Cannot uninstall &apos;XXXX&apos;. It is a distutils installed project and thus we cannot accurately determine which files belong to it which would lead to only a partial uninstall.</span><br></pre></td></tr></table></figure><p>其中，”XXXX“代表出现问题的资源，在遇到上述问题时，可尝试在anaconda路径下，搜索：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XXXX*.egg-info</span><br></pre></td></tr></table></figure><p>将出现的所有内容删除后，再次尝试安装即可。</p>]]></content>
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pip </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>tf_app_flags_FLAGS</title>
      <link href="/2020/07/11/tf_app_flags_FLAGS/"/>
      <url>/2020/07/11/tf_app_flags_FLAGS/</url>
      <content type="html"><![CDATA[<h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><p>tf.app.flags是Tensorflow提供的功能模块，用于Tensorflow在通过命令行运行脚本时，通过可选参数的形式修改原来脚本中指定变量的默认参数。</p><h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FLAGS = tf.app.flags.FLAGS  <span class="comment"># 定义变量，用于提取参数</span></span><br><span class="line"></span><br><span class="line">tf.app.flags.DEFINE_XXXX(flag_name=<span class="string">'xxx_n'</span>, default_value=xx, docstring=<span class="string">'xxx_h'</span>)</span><br></pre></td></tr></table></figure><p>其中，flag_name表示标志位的名称，default_value表示标志位的值，值的类型应与DEFINE_XXXX中的XXXX对应，其可选的数据类型有：string(即tf.app.flags.DEFINE_string，其它同理)、integer、DEFINE_boolean、float，当定义了指定标志位，在命令行运行过程中，可通过</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python py_filename.py --xxx_n1 --xxxn2</span><br></pre></td></tr></table></figure><p>来实现对脚本中，指定的变量内容的修改。</p><h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">FLAGS = tf.app.flags.FLAGS</span><br><span class="line"></span><br><span class="line">tf.app.flags.DEFINE_integer(flag_name=<span class="string">'a'</span>, default_value=<span class="number">64</span>,</span><br><span class="line">                            docstring=<span class="string">'变量a'</span>)</span><br><span class="line"><span class="comment"># 定义string型flag</span></span><br><span class="line">tf.app.flags.DEFINE_string(flag_name=<span class="string">'b'</span>, default_value=<span class="string">'hello world'</span>,</span><br><span class="line">                           docstring=<span class="string">'字符串b'</span>)</span><br><span class="line"></span><br><span class="line">print(FLAGS.a, FLAGS.b)</span><br></pre></td></tr></table></figure><p>编写上述脚本并保存到 ‘testFlag.py’ 文件中，通过命令提示符运行 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python testFlag.py</span><br></pre></td></tr></table></figure><p>得到输出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">64 hello world</span><br></pre></td></tr></table></figure><p>而如果在运行py文件的同时，对变量a和b进行赋值操作，即</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python testFlag.py --a 10 --b <span class="string">"Hello World"</span></span><br></pre></td></tr></table></figure><p>则有如下输出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10 Hello World</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> code </tag>
            
            <tag> Tensorflow </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python之Assert用法</title>
      <link href="/2020/05/29/Python%E4%B9%8BAssert%E7%94%A8%E6%B3%95/"/>
      <url>/2020/05/29/Python%E4%B9%8BAssert%E7%94%A8%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>Python 的assert可用于判断表达式是否成立，在表达式条件为 false 时候触发。在编程实现时，在有可能出现异常的位置建立判断表达式，用以及时发现并阻止程序的异常运行状态。</p><p>语法格式为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'方式1'</span></span><br><span class="line"><span class="keyword">assert</span> 表达式, 错误信息提示</span><br><span class="line"></span><br><span class="line"><span class="string">'方式2'</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> 表达式:</span><br><span class="line">    <span class="keyword">raise</span> AssertionError(错误信息提示)</span><br></pre></td></tr></table></figure><p>示例：</p><p>对变量a, b内容是否相等的判断</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line">b = <span class="number">1</span></span><br><span class="line"><span class="keyword">assert</span> a == b, <span class="string">'变量a,b不相等'</span></span><br></pre></td></tr></table></figure><p>运行结果无任何标识，即没有触发错误信息提示内容。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line">b = <span class="number">2</span></span><br><span class="line"><span class="keyword">assert</span> a == b, <span class="string">'变量a,b不相等'</span></span><br></pre></td></tr></table></figure><p>运行结果为</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">AssertionError: 变量a,b不相等</span><br></pre></td></tr></table></figure><p>由于表达式不成立，触发assert停止程序继续运行，并将错误信息提示内容打印。</p>]]></content>
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> code </tag>
            
            <tag> 异常处理 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>32位Win7显示“您的链接不是私密链接”</title>
      <link href="/2020/05/29/win732%E4%BD%8D%E5%AE%89%E8%A3%85%E8%B0%B7%E6%AD%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%BE%E7%A4%BA%E6%82%A8%E7%9A%84%E8%BF%9E%E6%8E%A5%E4%B8%8D%E6%98%AF%E7%A7%81%E5%AF%86%E8%BF%9E%E6%8E%A5/"/>
      <url>/2020/05/29/win732%E4%BD%8D%E5%AE%89%E8%A3%85%E8%B0%B7%E6%AD%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%BE%E7%A4%BA%E6%82%A8%E7%9A%84%E8%BF%9E%E6%8E%A5%E4%B8%8D%E6%98%AF%E7%A7%81%E5%AF%86%E8%BF%9E%E6%8E%A5/</url>
      <content type="html"><![CDATA[<p>在新安装的32位Win7系统中安装谷歌浏览器，在浏览https网页时，始终提示“您的连接不是私密连接”，并且部分网页不能够继续浏览，如图</p><p><img src="https://s1.ax1x.com/2020/04/15/J9312T.png" alt=""></p><p>可尝试在桌面快捷方式的“属性”-“目标”的末尾，添加 “—test-type —ignore-certificate-errors”即可</p><p><img src="https://s1.ax1x.com/2020/04/15/J9JAxK.png" alt=""></p>]]></content>
      
      <categories>
          
          <category> 故障排除 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 系统故障 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Matlab编程之绘图与可视化</title>
      <link href="/2020/05/28/Matlabplot%E5%87%BD%E6%95%B0_%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/"/>
      <url>/2020/05/28/Matlabplot%E5%87%BD%E6%95%B0_%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/</url>
      <content type="html"><![CDATA[<p>matlab具有强大的数据可视化能力，其常见的绘图函数包括plot、surf、bar等，可以满足大部分的可视化需求。</p><p><strong>官方示例：</strong></p><p>定义x轴为介于0-2pi之间的等分数组，使用正弦函数计算对应的y值。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">0</span>:<span class="built_in">pi</span>/<span class="number">100</span>:<span class="number">2</span>*<span class="built_in">pi</span>;</span><br><span class="line">y = <span class="built_in">sin</span>(x);</span><br></pre></td></tr></table></figure><p>使用plot函数创建图像</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">figure <span class="comment">% opens new figure window</span></span><br><span class="line">plot(x,y)</span><br></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2020/05/28/teDwIf.jpg" alt=""></p><h4 id="坐标轴设定"><a href="#坐标轴设定" class="headerlink" title="坐标轴设定"></a>坐标轴设定</h4><p>默认条件下，坐标轴是按照需要绘制数据的上下限来等分显示的。然而，在某些条件下，数据的非均匀分布、部分区间数据的突出显示等需求，使得坐标轴需要能够满足自定义设定。</p><h5 id="自定义放缩部分区间"><a href="#自定义放缩部分区间" class="headerlink" title="自定义放缩部分区间"></a>自定义放缩部分区间</h5><h6 id="简单"><a href="#简单" class="headerlink" title="简单"></a>简单</h6><p>对示例图像，如果想将区间[1, 2]的数据放大显示，而其它区间配合达到渐近变化效果，需对x轴数据进行调整，可根据想要突出显示的数值点手动设值</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = [<span class="number">0</span> <span class="number">1</span> <span class="number">1.2</span> <span class="number">1.4</span> <span class="number">1.5</span> <span class="number">1.6</span> <span class="number">1.8</span> <span class="number">2.0</span> <span class="number">4.0</span> <span class="number">8.0</span> <span class="number">10.0</span>];</span><br><span class="line">y = <span class="built_in">sin</span>(x);</span><br></pre></td></tr></table></figure><p>同时，绘图时窗口轴的设定相应修改</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">figure <span class="comment">% opens new figure window</span></span><br><span class="line">index = <span class="number">1</span>:<span class="built_in">length</span>(x);</span><br><span class="line">plot(index,y);</span><br><span class="line">set(gca,<span class="string">'XTick'</span>,index);</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="built_in">length</span>(x)</span><br><span class="line">    xTL = [xTL, &#123;num2str(x(i))&#125;];</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">set(gca,<span class="string">'XTickLabel'</span>,xTL);</span><br></pre></td></tr></table></figure><p>图像内容如下</p><p><img src="https://s1.ax1x.com/2020/05/28/te5k0U.jpg" alt=""></p><p>可以看出，由于绘制的数据点数过少，图像出现了严重的锯齿状。</p><h6 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h6><p>为解决上一问题，可在上述x数组的各点间均匀插值。在绘图时，只显示需要的几个点，即</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">x = [<span class="number">0</span> <span class="number">1</span> <span class="number">1.2</span> <span class="number">1.4</span> <span class="number">1.5</span> <span class="number">1.6</span> <span class="number">1.8</span> <span class="number">2.0</span> <span class="number">4.0</span> <span class="number">8.0</span> <span class="number">10.0</span>];</span><br><span class="line">X = [<span class="number">0</span>];</span><br><span class="line">rs = <span class="number">200</span>;</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="built_in">length</span>(x)<span class="number">-1</span></span><br><span class="line">    x_ = <span class="built_in">linspace</span>(x(<span class="built_in">i</span>), x(<span class="built_in">i</span>+<span class="number">1</span>), rs);</span><br><span class="line">    X = [X, x_(<span class="number">2</span>:end)];</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">y = <span class="built_in">sin</span>(X);</span><br></pre></td></tr></table></figure><p>绘图时窗口轴的设定相应修改</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">figure <span class="comment">% opens new figure window</span></span><br><span class="line">index = <span class="number">1</span>:<span class="built_in">length</span>(X);</span><br><span class="line">plot(index,y);</span><br><span class="line">set(gca,<span class="string">'XTick'</span>,index(<span class="number">1</span>:rs<span class="number">-1</span>:<span class="keyword">end</span>));</span><br><span class="line">xTL = [];</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="built_in">length</span>(x)</span><br><span class="line">    xTL = [xTL, &#123;num2str(x(i))&#125;];</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">set(gca,<span class="string">'XTickLabel'</span>,xTL);</span><br></pre></td></tr></table></figure><p>可得如下图像</p><p><img src="https://s1.ax1x.com/2020/05/28/teqBxH.jpg" alt=""></p><p>可以看出，经过处理的图像实现了平滑的显示，但在手动设定点处依然存在不平滑的现象。</p><h6 id="高级"><a href="#高级" class="headerlink" title="高级"></a>高级</h6><p>进一步，为了实现完全平滑的区间放大效果，引入高斯函数，设定放大中心点和放大比例。代码如下</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="built_in">linspace</span>(<span class="built_in">pi</span>,<span class="number">5</span>*<span class="built_in">pi</span>,<span class="number">500</span>);</span><br><span class="line"><span class="comment">%% x轴缩放设定</span></span><br><span class="line">center = <span class="number">6</span>/<span class="number">2</span>*<span class="built_in">pi</span>; <span class="comment">% 中心点位置</span></span><br><span class="line">scale = <span class="number">2</span>; <span class="comment">% &gt;0，缩放比例，随着数值的增大，放大效果减小</span></span><br><span class="line">X1 = <span class="number">1</span> ./ (<span class="number">0.01</span>/<span class="number">1000</span> + gaussmf(x,[scale, center]));</span><br><span class="line">X1 = X1 ./ max(X1);</span><br><span class="line">X1_min = min(X1);</span><br><span class="line">X2 = x(<span class="number">1</span>):X1_min:x(<span class="keyword">end</span>);</span><br><span class="line">X2 = [];</span><br><span class="line">X1_sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="built_in">length</span>(X1)</span><br><span class="line">    X1_sum = X1_sum + X1(<span class="built_in">i</span>);</span><br><span class="line">    X2 = [X2, X1_sum];</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">X2 = x(<span class="number">1</span>) + (X2 - min(X2)) .* (x(<span class="keyword">end</span>) - x(<span class="number">1</span>))/(X2(<span class="keyword">end</span>) - X2(<span class="number">1</span>));</span><br><span class="line"><span class="comment">%% 需要显示的函数</span></span><br><span class="line">y1 = <span class="built_in">sin</span>(x);</span><br><span class="line">y2 = <span class="built_in">sin</span>(X2);</span><br><span class="line"><span class="comment">%% 刻度设定</span></span><br><span class="line">index = <span class="number">1</span>:<span class="built_in">length</span>(X2);</span><br><span class="line">xTick_num = <span class="number">7</span>; <span class="comment">% 需要显示的刻度个数</span></span><br><span class="line">XTick_ = <span class="built_in">round</span>(<span class="built_in">linspace</span>(index(<span class="number">1</span>), index(<span class="keyword">end</span>), xTick_num));</span><br><span class="line">XTickLabel_ = X2(XTick_);</span><br><span class="line">XTickLabels_ = [];</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="built_in">length</span>(XTickLabel_)</span><br><span class="line">    XTickLabels_ = [XTickLabels_, &#123;num2str(XTickLabel_(i))&#125;];</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">%% 绘图</span></span><br><span class="line">figure</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">plot(x, y1)</span><br><span class="line">axis([x(<span class="number">1</span>) x(end) <span class="number">-1</span> <span class="number">1</span>]);</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">plot(index,y2)</span><br><span class="line">set(gca,<span class="string">'XTick'</span>,XTick_) <span class="comment">% 设定需要显示的刻度</span></span><br><span class="line">set(gca,<span class="string">'XTickLabel'</span>,XTickLabel_);</span><br></pre></td></tr></table></figure><p>可以得到如下图像</p><p><img src="https://s1.ax1x.com/2020/05/29/tmd5O1.jpg" alt=""></p><p>如此，只需要少量的设定操作即可得到完美的部分区间放大效果，但如果想进一步自定义效果，修改代码则相对繁琐。</p><p>当然，如果想部分突出y轴区间内容，则需要在得到的y轴数据中非等间隔提取y数据和对应的x数据，以基本同样的方式绘制图像。</p><h5 id="半对数坐标显示"><a href="#半对数坐标显示" class="headerlink" title="半对数坐标显示"></a>半对数坐标显示</h5><p>在没有苛刻要求的条件下，matlab同样提供了方便的半对数坐标，用于简单的实现非均匀刻度的坐标轴显示，半对数坐标系一个轴是分布均匀的普通坐标轴，另一个轴是分布不均匀的对数坐标轴。当横坐标为对数坐标时使用semilogx，而纵坐标为对数坐标时使用semilogy，两个坐标都需要对数形式时使用loglog(双对数)。以纵坐标为例，定义x, y轴数据</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="built_in">linspace</span>(<span class="number">0</span>,<span class="number">10</span>,<span class="number">1000</span>);</span><br><span class="line">y = x.^<span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>分别使用均匀坐标刻度显示和对数坐标刻度显示</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">figure</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>);</span><br><span class="line">plot(x,y);</span><br><span class="line">axis([<span class="number">0</span>,<span class="number">10</span>,<span class="number">0</span>,<span class="number">100</span>])</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>)</span><br><span class="line">semilogy(x,y)</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>)</span><br><span class="line">semilogy(x,y)</span><br><span class="line">set(gca,<span class="string">'YTick'</span>,[<span class="number">0.001</span> <span class="number">0.01</span> <span class="number">0.1</span> <span class="number">1</span> <span class="number">10</span> <span class="number">100</span>]) <span class="comment">% 设定需要显示的刻度</span></span><br><span class="line">set(gca, <span class="string">'YtickLabel'</span>, &#123;<span class="string">'0.001'</span>, <span class="string">'0.01'</span>, <span class="string">'0.1'</span>, <span class="string">'1'</span>, <span class="string">'10'</span>, <span class="string">'100'</span>&#125;); <span class="comment">% 修改显示的值</span></span><br></pre></td></tr></table></figure><p>如果不想使用默认的对数刻度显示形式，可以参照图3对应的代码修改y轴显示的数值内容，得到结果图像如下</p><p><img src="https://s1.ax1x.com/2020/05/28/tmSZNR.jpg" alt=""></p>]]></content>
      
      <categories>
          
          <category> matlab </category>
          
      </categories>
      
      
        <tags>
            
            <tag> code </tag>
            
            <tag> 可视化 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>GeoPandas安装与入门</title>
      <link href="/2020/04/15/Geopandas%E5%AE%89%E8%A3%85/"/>
      <url>/2020/04/15/Geopandas%E5%AE%89%E8%A3%85/</url>
      <content type="html"><![CDATA[<p>根据GeoPandas项目的描述，其是一个方便使用Python来进行地理空间数据处理的开源项目。GeoPandas扩展了Pandas的数据类型，可以使其在几何类型上进行空间操作。本文主要介绍安装过程和简易的入门应用。</p><h3 id="1、运行环境："><a href="#1、运行环境：" class="headerlink" title="1、运行环境："></a>1、运行环境：</h3><ul><li>Win 10 家庭版</li><li>Anaconda 3</li><li>python 3.6.2</li><li>pycharm</li></ul><h3 id="2、GeoPandas安装"><a href="#2、GeoPandas安装" class="headerlink" title="2、GeoPandas安装"></a>2、GeoPandas安装</h3><h4 id="2-1-依赖包安装"><a href="#2-1-依赖包安装" class="headerlink" title="2.1 依赖包安装"></a>2.1 依赖包安装</h4><p>从第三方插件库(<a href="https://www.lfd.uci.edu/~gohlke/pythonlibs/)依次下载并使用pip安装如下依赖：" target="_blank" rel="noopener">https://www.lfd.uci.edu/~gohlke/pythonlibs/)依次下载并使用pip安装如下依赖：</a></p><div class="table-container"><table><thead><tr><th style="text-align:center">依赖名称</th><th style="text-align:center">版本</th></tr></thead><tbody><tr><td style="text-align:center">Shapely</td><td style="text-align:center">1.7.0</td></tr><tr><td style="text-align:center">pyproj</td><td style="text-align:center">2.6.0</td></tr><tr><td style="text-align:center">GDAl</td><td style="text-align:center">3.0.4</td></tr><tr><td style="text-align:center">Fiona</td><td style="text-align:center">1.8.13</td></tr></tbody></table></div><h4 id="2-2-geopandas安装"><a href="#2-2-geopandas安装" class="headerlink" title="2.2 geopandas安装"></a>2.2 geopandas安装</h4><p>使用pip命令，安装geopandas即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install geopandas</span><br></pre></td></tr></table></figure><h3 id="3、简单示例"><a href="#3、简单示例" class="headerlink" title="3、简单示例"></a>3、简单示例</h3><h4 id="3-1-环境配置"><a href="#3-1-环境配置" class="headerlink" title="3.1 环境配置"></a>3.1 环境配置</h4><p>pycharm新建项目，为避免出现如下错误</p><p><img src="https://s1.ax1x.com/2020/04/14/JpGKRf.png" alt=""></p><p>在新建项目时，选择新建虚拟项目的同时，选中Inherit global site-packages复选框。</p><p><img src="https://s1.ax1x.com/2020/04/14/JpJZXF.png" alt=""></p><h4 id="3-2-绘制世界地图"><a href="#3-2-绘制世界地图" class="headerlink" title="3.2 绘制世界地图"></a>3.2 绘制世界地图</h4><p>新建py脚本，导入依赖</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> geopandas</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br></pre></td></tr></table></figure><p>读取geopandas自带的数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">world = geopandas.read_file(geopandas.datasets.get_path(<span class="string">'naturalearth_lowres'</span>))</span><br></pre></td></tr></table></figure><p>直接绘制地图数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">world.plot()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>将得到如下所示图像</p><p><img src="https://s1.ax1x.com/2020/04/14/JpU5a4.png" alt=""></p><h4 id="3-3-查看数据格式"><a href="#3-3-查看数据格式" class="headerlink" title="3.3 查看数据格式"></a>3.3 查看数据格式</h4><p>如果希望对导入的geopandas格式数据进行处理，则需要进一步了解该数据格式的组成。添加适应于数据表格显示的依赖，并设置pandas的显示属性。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pprint</span><br><span class="line"></span><br><span class="line"><span class="comment">#显示所有列</span></span><br><span class="line">pd.set_option(<span class="string">'display.max_columns'</span>, <span class="keyword">None</span>)</span><br><span class="line"><span class="comment">#显示5行</span></span><br><span class="line">pd.set_option(<span class="string">'display.max_rows'</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure><p>打印导入的世界地图数据，可以得到如下形式的输出</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pprint.pprint(world)</span><br></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2020/04/14/JpwZCj.png" alt=""></p><p>可以看出，数据格式依然保持表格的形式，而如果我们想在此基础上添加一些定制化的内容，如对不同的国家添加经济总量，并根据经济总量多少以不同颜色进行图像绘制，则可以按照与Pandas同样的操作进行。</p><p>例如，已知共有178个国家，设定属性“property_1”，为中国赋值为10000，其它国家为0。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">world[<span class="string">'property_1'</span>] = pd.Series(np.array(list(range(<span class="number">1</span>, <span class="number">178</span>))))</span><br><span class="line"></span><br><span class="line">index = world[world.name == <span class="string">'China'</span>].haha.tolist()</span><br><span class="line">index = index[<span class="number">0</span>]<span class="number">-1</span></span><br><span class="line"></span><br><span class="line">world.loc[index, <span class="string">'property_1'</span>] = <span class="number">10000</span></span><br></pre></td></tr></table></figure><p>在此基础上，参照各个国家的“property_1”值绘制图像。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fig, ax = plt.subplots(<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">world.plot(column=<span class="string">'property_1'</span>, ax=ax, legend=<span class="keyword">True</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2020/04/14/JpR04x.png" alt=""></p><p>以上是对geopandas的安装和简单应用，可根据实际需求做进一步了解和应用。</p>]]></content>
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> code </tag>
            
            <tag> 可视化 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hexo本地部署</title>
      <link href="/2020/04/14/Hexo%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2/"/>
      <url>/2020/04/14/Hexo%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2/</url>
      <content type="html"><![CDATA[<p>学习使用Hexo在本地搭建个人博客，并通过nginx服务器进行部署。</p><h3 id="1、准备工作："><a href="#1、准备工作：" class="headerlink" title="1、准备工作："></a>1、准备工作：</h3><ul><li>下载安装Git客户端，官网链接 <a href="https://git-scm.com/downloads" target="_blank" rel="noopener">https://git-scm.com/downloads</a></li><li>下载安装node.js， 官网链接 <a href="http://nodejs.cn/download/" target="_blank" rel="noopener">http://nodejs.cn/download/</a></li><li>下载nginx并解压到本地目录，后面部署博客时将会用到，官网链接 <a href="http://nginx.org/en/download.html" target="_blank" rel="noopener">http://nginx.org/en/download.html</a></li></ul><h3 id="2、Hexo安装配置"><a href="#2、Hexo安装配置" class="headerlink" title="2、Hexo安装配置"></a>2、Hexo安装配置</h3><h4 id="2-1-hexo-安装"><a href="#2-1-hexo-安装" class="headerlink" title="2.1 hexo 安装"></a>2.1 hexo 安装</h4><p>在本地任意目录下新建文件夹，文件夹命名自定义。鼠标右击该文件夹选择“Git Bash Here”。</p><p><img src="https://s1.ax1x.com/2020/04/14/JS19fO.png" alt=""></p><p>在启动的终端界面中，输入如下命令进行hexo的安装，当出现下图所示内容时，表示安装成功。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2020/04/14/JS3trd.png" alt=""></p><h4 id="2-2-初始化与生成"><a href="#2-2-初始化与生成" class="headerlink" title="2.2 初始化与生成"></a>2.2 初始化与生成</h4><p>运行初始化方法，初始化新建博客项目。其中，i是初始化init的缩写，blog代表项目名。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo i blog</span><br></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2020/04/14/JS5ssS.png" alt=""></p><p>通过cd命令切换到新建的博客项目中，使用generate或g生成博客。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 切换到博客目录</span><br><span class="line">cd blog </span><br><span class="line"></span><br><span class="line">// 两种博客生成方式</span><br><span class="line">hexo g</span><br><span class="line">hexo generate</span><br></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2020/04/14/JS5IMT.png" alt=""></p><h4 id="2-3-本地发布"><a href="#2-3-本地发布" class="headerlink" title="2.3 本地发布"></a>2.3 本地发布</h4><p>通过服务命令来实现构建博客的本地发布</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 两种博客发布方式</span><br><span class="line">hexo s</span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2020/04/14/JSIkFA.png" alt=""></p><p>运行成功后，通过提示信息可以看到，在浏览器输入<a href="http://localhost:4000便可以访问刚刚构建成功的本地博客。" target="_blank" rel="noopener">http://localhost:4000便可以访问刚刚构建成功的本地博客。</a></p><p><img src="https://s1.ax1x.com/2020/04/14/JSIDYR.png" alt=""></p><p>如果想停止启动的服务，通过组合键“ctrl+c”即可。自带的主题形式比较单一，可以在hexo的主题官网<a href="https://hexo.io/themes/查找自己喜欢的主题，或者配置符合自己审美的自定义布局，不再赘述。" target="_blank" rel="noopener">https://hexo.io/themes/查找自己喜欢的主题，或者配置符合自己审美的自定义布局，不再赘述。</a></p><h3 id="3、Nginx部署"><a href="#3、Nginx部署" class="headerlink" title="3、Nginx部署"></a>3、Nginx部署</h3><h4 id="3-1-nginx解压"><a href="#3-1-nginx解压" class="headerlink" title="3.1 nginx解压"></a>3.1 nginx解压</h4><p>通过hexo s命令启动的博客服务，据说效率较低，因此使用简单高效的nginx服务器来实现博客的部署。将下载好的nginx压缩包解压到本地任意目录。</p><p><img src="https://s1.ax1x.com/2020/04/14/JSooE4.png" alt=""></p><h4 id="3-2-修改默认访问端口，可选"><a href="#3-2-修改默认访问端口，可选" class="headerlink" title="3.2 修改默认访问端口，可选"></a>3.2 修改默认访问端口，可选</h4><p>为防止由于80端口占用导致的访问失败，可提前修改默认访问端口。打开nginx解压后目录中的配置文件conf/nginx.conf，编辑nginx服务器的默认端口，找到如下代码，修改listen监听的端口号为自定义端口号</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen       8080; // 默认 80</span><br><span class="line">        server_name  localhost;</span><br><span class="line">        #charset koi8-r;</span><br><span class="line">        #access_log  logs/host.access.log  main;</span><br><span class="line">        location / &#123;</span><br><span class="line">            root   html;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-nginx访问"><a href="#3-3-nginx访问" class="headerlink" title="3.3 nginx访问"></a>3.3 nginx访问</h4><p>打开cmd并切换到nginx解压目录，运行命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">start nginx</span><br></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2020/04/14/JSbZqK.png" alt=""></p><p>在浏览器输入<a href="http://127.0.0.1:8080即可看到nginx的欢迎界面，其中8080为自定义的端口号。" target="_blank" rel="noopener">http://127.0.0.1:8080即可看到nginx的欢迎界面，其中8080为自定义的端口号。</a></p><p><img src="https://s1.ax1x.com/2020/04/14/JSbtZ8.png" alt=""></p><h4 id="3-4-nginx部署hexo"><a href="#3-4-nginx部署hexo" class="headerlink" title="3.4 nginx部署hexo"></a>3.4 nginx部署hexo</h4><p>将hexo g命令生成的博客中的public文件夹(默认生成的静态站点)，复制到nginx目录下的html文件夹中，并修改刚才的配置文件conf/nginx.conf</p><p><img src="https://s1.ax1x.com/2020/04/14/JSqHcn.png" alt=""></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen       8080; // 默认 80</span><br><span class="line">        server_name  localhost;</span><br><span class="line">        #charset koi8-r;</span><br><span class="line">        #access_log  logs/host.access.log  main;</span><br><span class="line">        location / &#123;</span><br><span class="line">            root   html/public; // 由html改为html/public</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>在命令行使用nginx服务的重新加载功能，即可实现对public博客内容的显示。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2020/04/14/JSL0uq.png" alt=""></p><p>至此，便完成了hexo的本地部署，如果想通过域名访问，则可以购买一个实惠的域名，找一个趁手的内网穿透工具以实现域名访问。</p>]]></content>
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> code </tag>
            
            <tag> 博客搭建 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python-多线程与多进程</title>
      <link href="/2018/06/21/Python%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%A4%9A%E8%BF%9B%E7%A8%8B/"/>
      <url>/2018/06/21/Python%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%A4%9A%E8%BF%9B%E7%A8%8B/</url>
      <content type="html"><![CDATA[<h2 id="多线程与多进程"><a href="#多线程与多进程" class="headerlink" title="多线程与多进程:"></a>多线程与多进程:</h2><p>​    python中可方便实现多线程与多进程. 而由于全局解释器锁的存在, 多线程实际为将多个单线程拆分为执行序列, 每个时刻只执行其中一个线程, 因而python中的多线程更适合于IO密集型操作. 为充分利用多核cpu资源, 执行计算密集型操作, 可引用多进程操作.</p><p>​    接下在就工程中涉及到的多线程与多进程应用的数种方法, 示例记录, 便于记忆.</p><h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程:"></a>多线程:</h3><p>导入环境</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading</span><br></pre></td></tr></table></figure><p>在派生类中重写父类threading.Thread的run()方法. 注意, 子类中只有<strong>init</strong>()和<strong>run</strong>()方法被重写. 然后在主线程中生成子线程类的对象, 调用<strong>start</strong>()方法运行.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        threading.Thread.__init__(self)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">global</span> iterNum, threadLock  <span class="comment"># 多线程中, 通过定义全局变量实现数据共享</span></span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> threadLock.acquire():</span><br><span class="line">            print(iterNum , self.name)</span><br><span class="line">            iterNum += <span class="number">1</span></span><br><span class="line">            threadLock.release()</span><br></pre></td></tr></table></figure><p>主程序中创建线程并调用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="string">"__main__"</span> == __name__:</span><br><span class="line">    </span><br><span class="line">    start_time = time.time()</span><br><span class="line">    print(<span class="string">'主线程名称：'</span>, threading.current_thread().name)</span><br><span class="line"></span><br><span class="line">    iterNum = <span class="number">1</span></span><br><span class="line">    threadList = []</span><br><span class="line">    lock = threading.Lock()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 创建200个线程, 存入list</span></span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        thread_ = MyThread()</span><br><span class="line">        threadList.append(index)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 开启线程</span></span><br><span class="line">    <span class="keyword">for</span> thread_ <span class="keyword">in</span> ThreadList:</span><br><span class="line">        <span class="comment"># thread_.setDaemon(True)  # 设置线程守护</span></span><br><span class="line">        thread_.start()</span><br><span class="line">            </span><br><span class="line">    print(<span class="string">'主线程: '</span> + threading.current_thread().name + <span class="string">'结束'</span>)</span><br><span class="line">    print(<span class="string">'共计耗时：'</span>, time.time()-start_time)</span><br></pre></td></tr></table></figure><p>上述代码中, 通过start()方法开启线程. 注意到, 开启线程前存在一个注释掉的守护线程<strong>setDaemon</strong>().  <strong>setDaemon</strong>()默认<strong>false</strong>, 表示主线程执行完任务后会退出, 而子线程继续执行直到任务完成. 该条件下, 结果如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">主线程名称： MainThread</span><br><span class="line">主线程: MainThread结束</span><br><span class="line">共计耗时： <span class="number">0.0010030269622802734</span></span><br><span class="line"><span class="number">1</span> Thread<span class="number">-4</span></span><br><span class="line"><span class="number">2</span> Thread<span class="number">-1</span></span><br><span class="line"><span class="number">3</span> Thread<span class="number">-5</span></span><br><span class="line"><span class="number">4</span> Thread<span class="number">-2</span></span><br><span class="line"><span class="number">5</span> Thread<span class="number">-3</span></span><br><span class="line"></span><br><span class="line">Process finished <span class="keyword">with</span> exit code <span class="number">0</span></span><br></pre></td></tr></table></figure><p>接下来, 取消注释, 设置守护线程为<strong>true</strong>, 代码为:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="string">"__main__"</span> == __name__:</span><br><span class="line">    </span><br><span class="line">    start_time = time.time()</span><br><span class="line">    print(<span class="string">'主线程名称：'</span>, threading.current_thread().name)</span><br><span class="line"></span><br><span class="line">    iterNum = <span class="number">1</span></span><br><span class="line">    threadList = []</span><br><span class="line">    lock = threading.Lock()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 创建200个线程, 存入list</span></span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        thread_ = MyThread()</span><br><span class="line">        threadList.append(index)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 开启线程</span></span><br><span class="line">    <span class="keyword">for</span> thread_ <span class="keyword">in</span> ThreadList:</span><br><span class="line">        thread_.setDaemon(<span class="keyword">True</span>)  <span class="comment"># 设置线程守护</span></span><br><span class="line">        thread_.start()</span><br><span class="line">            </span><br><span class="line">    print(<span class="string">'主线程: '</span> + threading.current_thread().name + <span class="string">'结束'</span>)</span><br><span class="line">    print(<span class="string">'共计耗时：'</span>, time.time()-start_time)</span><br></pre></td></tr></table></figure><p>结果如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">主线程名称： MainThread</span><br><span class="line">主线程: MainThread结束</span><br><span class="line">共计耗时： <span class="number">0.0009665489196777344</span></span><br><span class="line"></span><br><span class="line">Process finished <span class="keyword">with</span> exit code <span class="number">0</span></span><br></pre></td></tr></table></figure><p>可以看出, 主线程运行结束, 由于守护线程的缘故, 直接将子线程杀死, 不再继续运行. 而部分条件下, 我们需要的结果是当主线程开启, 等待子线程运行结束后, 再结束主线程. 此时, 可以通过使用<strong>join</strong>()来实现, 代码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="string">"__main__"</span> == __name__:</span><br><span class="line">    </span><br><span class="line">    start_time = time.time()</span><br><span class="line">    print(<span class="string">'主线程名称：'</span>, threading.current_thread().name)</span><br><span class="line"></span><br><span class="line">    iterNum = <span class="number">1</span></span><br><span class="line">    threadList = []</span><br><span class="line">    lock = threading.Lock()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 创建200个线程, 存入list</span></span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        thread_ = MyThread()</span><br><span class="line">        threadList.append(index)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 开启线程</span></span><br><span class="line">    <span class="keyword">for</span> thread_ <span class="keyword">in</span> ThreadList:</span><br><span class="line">        thread_.setDaemon(<span class="keyword">True</span>)  <span class="comment"># 设置线程守护</span></span><br><span class="line">        thread_.start()</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">for</span> thread_ <span class="keyword">in</span> ThreadList:</span><br><span class="line">        thread_.join()</span><br><span class="line">    </span><br><span class="line">    print(<span class="string">'主线程: '</span> + threading.current_thread().name + <span class="string">'结束'</span>)</span><br><span class="line">    print(<span class="string">'共计耗时：'</span>, time.time()-start_time)</span><br></pre></td></tr></table></figure><p><strong>join</strong>()中存在一个<strong>timeout</strong>参数, 当设置守护线程时, 主线程等待<strong>timeout</strong>时间后再执行杀死子线程的操作. 当<strong>timeout</strong>不设定时, 表示等待子线程运行结束后, 再结束主线程. 上述代码运行结果如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">主线程名称： MainThread</span><br><span class="line"><span class="number">1</span> Thread<span class="number">-5</span></span><br><span class="line"><span class="number">2</span> Thread<span class="number">-2</span></span><br><span class="line"><span class="number">3</span> Thread<span class="number">-3</span></span><br><span class="line"><span class="number">4</span> Thread<span class="number">-1</span></span><br><span class="line"><span class="number">5</span> Thread<span class="number">-4</span></span><br><span class="line">主线程: MainThread结束</span><br><span class="line">共计耗时： <span class="number">1.006718397140503</span></span><br><span class="line"></span><br><span class="line">Process finished <span class="keyword">with</span> exit code <span class="number">0</span></span><br></pre></td></tr></table></figure><p>可以看出, 主线程以及计时均等待子线程结束后才开始实现. 当设定<strong>timeout</strong>时, 以下述两种情况为例:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设定 timeout = 0, 则5个子线程共计等待 0 * 5 = 0s, 即主线程不等待直接杀死子线程.</span></span><br><span class="line"><span class="keyword">for</span> thread_ <span class="keyword">in</span> ThreadList:</span><br><span class="line">    thread_.join(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">主线程名称： MainThread</span><br><span class="line">主线程: MainThread结束</span><br><span class="line">共计耗时： <span class="number">0.005353212356567383</span></span><br><span class="line"></span><br><span class="line">Process finished <span class="keyword">with</span> exit code <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设定 timeout = 0.2, 则5个子线程共计等待 0.2 * 5 = 1s, 主线程等待1s后杀死子线程.</span></span><br><span class="line"><span class="keyword">for</span> thread_ <span class="keyword">in</span> ThreadList:</span><br><span class="line">    thread_.join(<span class="number">0.2</span>)</span><br><span class="line"></span><br><span class="line">主线程名称： MainThread</span><br><span class="line"><span class="number">1</span> Thread<span class="number">-3</span></span><br><span class="line"><span class="number">2</span> Thread<span class="number">-1</span></span><br><span class="line"><span class="number">3</span> Thread<span class="number">-5</span></span><br><span class="line">主线程: MainThread结束</span><br><span class="line">共计耗时： <span class="number">1.0059242248535156</span></span><br><span class="line"></span><br><span class="line">Process finished <span class="keyword">with</span> exit code <span class="number">0</span></span><br></pre></td></tr></table></figure><p>可以看出, 当<strong>timeout</strong>设定为0.2s时, 有三个子线程运行结束, 仍有两个没来得及运行即被杀死.</p><h3 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h3><p>​    相对于多线程来说, 多进程操作中, 每一个子进程会作为真正独立的程序运行. 多线程运行过程中, 一个线程异常将导致整个程序故障. 而多进程中, 一个子进程异常基本不会影响其他进程的运行, 因而具有一定的稳定性, 但也较难以调试和控制. 此外, 多进程间的数据传递无法通过设置全局变量实现, 必须通过其专有的队列, 管道或共享内存的方式实现.</p><p>导入环境</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br></pre></td></tr></table></figure><p>为防止由于多个子进程导致的系统假死, 在主函数的最开始, 添加如下语句:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">multiprocessing.freeze_support()</span><br></pre></td></tr></table></figure><p>启动子进程的几种方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方法1</span></span><br><span class="line">process1 = multiprocessing.Process(target=processFun1, args=(param,))</span><br><span class="line">process2 = multiprocessing.Process(target=processFun2, args=(param,))</span><br><span class="line"></span><br><span class="line">process1.start()</span><br><span class="line">process2.start()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法2:</span></span><br><span class="line">pool = multiprocessing.Pool(processes=<span class="number">2</span>)  <span class="comment"># 创建进程池, 参数可缺省</span></span><br><span class="line"></span><br><span class="line">pool.apply_async(processFun1, (param, ))</span><br><span class="line">pool.apply_async(processFun2, (param, ))</span><br><span class="line"></span><br><span class="line">pool.close() <span class="comment"># 关闭进程池，表示不能在往进程池中添加进程</span></span><br><span class="line">pool.join()  <span class="comment"># 含义同多线程join()，必须在close()之后调用</span></span><br></pre></td></tr></table></figure><p>进程间数据共享支持queue, pipi, value和array. 但是python提供的更高层次的封装, 在我觉得使用起来更加方便, 而这些高级接口的调用, 可通过multiprocessing.Manager()方便的进行调用.</p><p>multiprocessing.Manager()支持list, dict, Namespace, Lock, RLock, Semaphore, BoundedSemaphore, Condition, Event, Queue, Value和Array.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">multiProcessManager = multiprocessing.Manager()</span><br><span class="line"><span class="comment"># list定义与调用示例</span></span><br><span class="line">mPMList = multiProcessManager.list([<span class="number">0</span>] * <span class="number">10</span>)</span><br><span class="line">callLlist = mPMList.value</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> code </tag>
            
            <tag> 并行计算 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python-SQL Server数据库</title>
      <link href="/2018/06/20/PythonSqlServer%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
      <url>/2018/06/20/PythonSqlServer%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
      <content type="html"><![CDATA[<h2 id="SQL-Server-数据库-1"><a href="#SQL-Server-数据库-1" class="headerlink" title="SQL Server 数据库(1):"></a>SQL Server 数据库(1):</h2><p>导入环境:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pymssql</span><br><span class="line"><span class="keyword">import</span> adodbapi</span><br></pre></td></tr></table></figure><p>建立数据库连接</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方法一</span></span><br><span class="line">conn = adodbapi.connect(<span class="string">"Provider=SQLOLEDB; SERVER='IP地址:端口'; Initial Catalog=数据库名称;User Id=sa; Password=密码; "</span>)</span><br><span class="line"><span class="comment"># 方法二</span></span><br><span class="line">conn = pymssql.connect(host=<span class="string">'IP地址:端口'</span>, user=<span class="string">'sa'</span>, password=<span class="string">'密码'</span>, database=<span class="string">'数据库名称'</span>, charset=<span class="string">'utf8'</span>)</span><br></pre></td></tr></table></figure><p>使用连接对象获得一个cursor对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cursor = conn.cursor()</span><br></pre></td></tr></table></figure><p>使用cursor操作数据库操 </p><p>命令汇总:</p><ul><li>callproc(self, procname, args):  </li><li>execute(self, query, args):  </li><li>executemany(self, query, args):  </li><li>nextset(self):</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用示例</span></span><br><span class="line">sql=<span class="string">"insert into student values (%s,%s,%s)"</span>  <span class="comment"># 所有数据类型均用s%</span></span><br><span class="line">param=(<span class="number">1</span>, ManQi,<span class="number">18</span>)  <span class="comment"># param应为tuple或list</span></span><br><span class="line"><span class="comment"># 插入一条数据</span></span><br><span class="line">n=cursor.execute(sql,param)</span><br></pre></td></tr></table></figure><p>执行cursor接收操作数据库返回值.</p><p>方法汇总:</p><ul><li>fetchall(self): 接收全部元组.</li><li>fetchmany(self, size=None): 接收不大于size条返回结果行.</li><li>fetchone(self): 返回一条元组.</li><li>scroll(self, value, mode=’relative’): </li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result = cursor.fetchall()  <span class="comment"># result为tuple类型, 其中单条结果也为tuple类型数据,</span></span><br></pre></td></tr></table></figure><p>在对数据库进行增删操作后, 需提交. 否则修改无效.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conn.commit()</span><br></pre></td></tr></table></figure><p>操作结束, 执行关闭操作.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cursor.close()  <span class="comment"># 关闭指针对象</span></span><br><span class="line">conn.close()  <span class="comment"># 关闭连接对象</span></span><br></pre></td></tr></table></figure><p>附, 简单的数据库语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">表: student</span></span><br><span class="line"><span class="comment">结构: id(int), name(varchar(MAX)), age(varchar(MAX))</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">--插入一条数据</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student <span class="keyword">values</span> (<span class="number">1</span>,ManQi,<span class="number">18</span>)</span><br><span class="line"><span class="comment">--返回名为ManQi, 且年龄为空的第一条数据</span></span><br><span class="line"><span class="keyword">select</span> top <span class="number">1</span> <span class="keyword">id</span> <span class="keyword">from</span> student <span class="keyword">where</span> (<span class="keyword">name</span> = <span class="string">'ManQi'</span>) <span class="keyword">and</span> (age <span class="keyword">is</span> <span class="literal">null</span>)</span><br><span class="line"><span class="comment">--更新id为1的名字</span></span><br><span class="line"><span class="keyword">update</span> student <span class="keyword">set</span> <span class="keyword">name</span> = <span class="string">'TY'</span> <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span></span><br><span class="line"><span class="comment">--即删除字段为某值的所有记录</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> 表名 <span class="keyword">where</span> 字段=某值 </span><br><span class="line"><span class="comment">--将表中字段为某值的替换为null</span></span><br><span class="line"><span class="keyword">update</span> 表名 <span class="keyword">set</span> 字段=<span class="literal">null</span> <span class="keyword">where</span> 字段=某值 </span><br><span class="line"><span class="comment">--显示表格所有信息</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> student</span><br><span class="line"><span class="comment">/*注意到, sql中空为null, python中为none*/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> code </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
