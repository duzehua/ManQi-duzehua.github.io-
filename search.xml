<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>机器人学-学习笔记</title>
      <link href="/2018/06/26/%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%AD%A6/"/>
      <url>/2018/06/26/%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%AD%A6/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言:"></a>前言:</h2><p>​    ——距离放下这门课已经差不多一年了, 知识点也已经忘了十有七八. 真是年龄越长, 忘性越大. 遂打算业余时间翻看翻看之前的书籍, 做做笔记. 也不枉学过一番.</p><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="机器人位-置-姿-态-表示"><a href="#机器人位-置-姿-态-表示" class="headerlink" title="机器人位(置)姿(态) 表示"></a>机器人位(置)姿(态) 表示</h3><p>​    由于需要描述机器人不同部件之间, 以及机器人与外界之间的相对关系(通常指位姿关系), 需用到空间位置矢量, 姿态角等信息.</p><h4 id="空间位置"><a href="#空间位置" class="headerlink" title="空间位置"></a>空间位置</h4><p>​    通常使用笛卡尔空间坐标系描述相对位置关系, 应用3x1的位置矢量描述空间任意一点的位置. 对笛卡尔坐标系{<em>A</em>}, 空间任意一点p的位置可描述为:</p><script type="math/tex; mode=display">{}^Ap = \left[ {\begin{array}{*{20}{c}}   {p_x}  \\   {p_y}  \\   {p_z}  \\\end{array}} \right]</script><p>$p_x$ , $p_y$ 和$p_z$ 为点<em>p</em> 沿坐标系{<em>A</em>}的<em>x,y,z</em>三个轴线方向的坐标分量. 其中, $^Ap$ 中上标<em>A</em>代表参考坐标系{<em>A</em>}, 称$^Ap$为位置矢量.</p><h4 id="姿态描述"><a href="#姿态描述" class="headerlink" title="姿态描述"></a>姿态描述</h4><p>​    为完成位姿关系的描述, 除要表示空间位置关系外, 还需要表示物体此时所处姿态(可理解为朝向).  首先直接来看一组姿态表示, 刚体<em>B</em>在坐标系{<em>A</em>} 中的姿态描述:</p><script type="math/tex; mode=display">_B^AR = \left[ {\begin{array}{*{20}{c}}   {^A{x_B}} & {^A{y_B}} & {^A{z_B}}  \\\end{array}} \right] = \left[ {\begin{array}{*{20}{c}}   {r_{11}} & {r_{12}} & {r_{13}}  \\   {r_{21}} & {r_{22}} & {r_{23}}  \\   {r_{31}} & {r_{32}} & {r_{33}}  \\\end{array}} \right]</script><p>其中, $_B^AR $表示以坐标系{<em>A</em>}为参考坐标系, 刚体<em>B</em>的姿态表示(<em>{B}</em>表示被描述的坐标系). 相对空间位置, 对初学者来说比较难以理解. 可以尝试从二维条件理解, 然后拓展到三维环境下.</p><p>首先看一组二维环境下的效果图:</p><p><img src="D:\HexoWorkSpace\blog\source\postImage\2DRotate.gif" alt="image"></p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献:="></a>参考文献:=</h2><ol><li>机器人学, 蔡自兴</li><li>…</li></ol>]]></content>
      
      <categories>
          
          <category> 机器人 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器人学 </tag>
            
            <tag> 运动学 </tag>
            
            <tag> 动力学 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python-SQL Server数据库</title>
      <link href="/2018/06/21/PythonSqlServer%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
      <url>/2018/06/21/PythonSqlServer%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
      <content type="html"><![CDATA[<h2 id="SQL-Server-数据库-待完善"><a href="#SQL-Server-数据库-待完善" class="headerlink" title="SQL Server 数据库(待完善):"></a>SQL Server 数据库(待完善):</h2><p>导入环境:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pymssql</span><br><span class="line"><span class="keyword">import</span> adodbapi</span><br></pre></td></tr></table></figure><p>建立数据库连接</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方法一</span></span><br><span class="line">conn = adodbapi.connect(<span class="string">"Provider=SQLOLEDB; SERVER='IP地址:端口'; Initial Catalog=数据库名称;User Id=sa; Password=密码; "</span>)</span><br><span class="line"><span class="comment"># 方法二</span></span><br><span class="line">conn = pymssql.connect(host=<span class="string">'IP地址:端口'</span>, user=<span class="string">'sa'</span>, password=<span class="string">'密码'</span>, database=<span class="string">'数据库名称'</span>, charset=<span class="string">'utf8'</span>)</span><br></pre></td></tr></table></figure><p>使用连接对象获得一个cursor对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cursor = conn.cursor()</span><br></pre></td></tr></table></figure><p>使用cursor操作数据库操 </p><p>命令汇总:</p><ul><li>callproc(self, procname, args):  </li><li>execute(self, query, args):  </li><li>executemany(self, query, args):  </li><li>nextset(self):</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用示例</span></span><br><span class="line">sql=<span class="string">"insert into student values (%s,%s,%s)"</span>  <span class="comment"># 所有数据类型均用s%</span></span><br><span class="line">param=(<span class="number">1</span>, ManQi,<span class="number">18</span>)  <span class="comment"># param应为tuple或list</span></span><br><span class="line"><span class="comment"># 插入一条数据</span></span><br><span class="line">n=cursor.execute(sql,param)</span><br></pre></td></tr></table></figure><p>执行cursor接收操作数据库返回值.</p><p>方法汇总:</p><ul><li>fetchall(self): 接收全部元组.</li><li>fetchmany(self, size=None): 接收不大于size条返回结果行.</li><li>fetchone(self): 返回一条元组.</li><li>scroll(self, value, mode=’relative’): </li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result = cursor.fetchall()  <span class="comment"># result为tuple类型, 其中单条结果也为tuple类型数据,</span></span><br></pre></td></tr></table></figure><p>在对数据库进行增删操作后, 需提交. 否则修改无效.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conn.commit()</span><br></pre></td></tr></table></figure><p>操作结束, 执行关闭操作.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cursor.close()  <span class="comment"># 关闭指针对象</span></span><br><span class="line">conn.close()  <span class="comment"># 关闭连接对象</span></span><br></pre></td></tr></table></figure><p>附, 简单的数据库语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">表: student</span></span><br><span class="line"><span class="comment">结构: id(int), name(varchar(MAX)), age(varchar(MAX))</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">--插入一条数据</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student <span class="keyword">values</span> (<span class="number">1</span>,ManQi,<span class="number">18</span>)</span><br><span class="line"><span class="comment">--返回名为ManQi, 且年龄为空的第一条数据</span></span><br><span class="line"><span class="keyword">select</span> top <span class="number">1</span> <span class="keyword">id</span> <span class="keyword">from</span> student <span class="keyword">where</span> (<span class="keyword">name</span> = <span class="string">'ManQi'</span>) <span class="keyword">and</span> (age <span class="keyword">is</span> <span class="literal">null</span>)</span><br><span class="line"><span class="comment">--更新id为1的名字</span></span><br><span class="line"><span class="keyword">update</span> student <span class="keyword">set</span> <span class="keyword">name</span> = <span class="string">'TY'</span> <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span></span><br><span class="line"><span class="comment">--即删除字段为某值的所有记录</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> 表名 <span class="keyword">where</span> 字段=某值 </span><br><span class="line"><span class="comment">--将表中字段为某值的替换为null</span></span><br><span class="line"><span class="keyword">update</span> 表名 <span class="keyword">set</span> 字段=<span class="literal">null</span> <span class="keyword">where</span> 字段=某值 </span><br><span class="line"><span class="comment">--显示表格所有信息</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> student</span><br><span class="line"><span class="comment">/*注意到, sql中空为null, python中为none*/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python-多线程与多进程</title>
      <link href="/2018/06/21/Python%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%A4%9A%E8%BF%9B%E7%A8%8B/"/>
      <url>/2018/06/21/Python%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%A4%9A%E8%BF%9B%E7%A8%8B/</url>
      <content type="html"><![CDATA[<h2 id="多线程与多进程"><a href="#多线程与多进程" class="headerlink" title="多线程与多进程:"></a>多线程与多进程:</h2><p>​    python中可方便实现多线程与多进程. 而由于全局解释器锁的存在, 多线程实际为将多个单线程拆分为执行序列, 每个时刻只执行其中一个线程, 因而python中的多线程更适合于IO密集型操作. 为充分利用多核cpu资源, 执行计算密集型操作, 可引用多进程操作.</p><p>​    接下在就工程中涉及到的多线程与多进程应用的数种方法, 示例记录, 便于记忆.</p><h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程:"></a>多线程:</h3><p>导入环境</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading</span><br></pre></td></tr></table></figure><p>在派生类中重写父类threading.Thread的run()方法. 注意, 子类中只有<strong>init</strong>()和<strong>run</strong>()方法被重写. 然后在主线程中生成子线程类的对象, 调用<strong>start</strong>()方法运行.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        threading.Thread.__init__(self)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">global</span> iterNum, threadLock  <span class="comment"># 多线程中, 通过定义全局变量实现数据共享</span></span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> threadLock.acquire():</span><br><span class="line">            print(iterNum , self.name)</span><br><span class="line">            iterNum += <span class="number">1</span></span><br><span class="line">            threadLock.release()</span><br></pre></td></tr></table></figure><p>主程序中创建线程并调用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="string">"__main__"</span> == __name__:</span><br><span class="line">    </span><br><span class="line">    start_time = time.time()</span><br><span class="line">    print(<span class="string">'主线程名称：'</span>, threading.current_thread().name)</span><br><span class="line"></span><br><span class="line">    iterNum = <span class="number">1</span></span><br><span class="line">    threadList = []</span><br><span class="line">    lock = threading.Lock()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 创建200个线程, 存入list</span></span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        thread_ = MyThread()</span><br><span class="line">        threadList.append(index)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 开启线程</span></span><br><span class="line">    <span class="keyword">for</span> thread_ <span class="keyword">in</span> ThreadList:</span><br><span class="line">        <span class="comment"># thread_.setDaemon(True)  # 设置线程守护</span></span><br><span class="line">        thread_.start()</span><br><span class="line">            </span><br><span class="line">    print(<span class="string">'主线程: '</span> + threading.current_thread().name + <span class="string">'结束'</span>)</span><br><span class="line">    print(<span class="string">'共计耗时：'</span>, time.time()-start_time)</span><br></pre></td></tr></table></figure><p>上述代码中, 通过start()方法开启线程. 注意到, 开启线程前存在一个注释掉的守护线程<strong>setDaemon</strong>().  <strong>setDaemon</strong>()默认<strong>false</strong>, 表示主线程执行完任务后会退出, 而子线程继续执行直到任务完成. 该条件下, 结果如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">主线程名称： MainThread</span><br><span class="line">主线程: MainThread结束</span><br><span class="line">共计耗时： <span class="number">0.0010030269622802734</span></span><br><span class="line"><span class="number">1</span> Thread<span class="number">-4</span></span><br><span class="line"><span class="number">2</span> Thread<span class="number">-1</span></span><br><span class="line"><span class="number">3</span> Thread<span class="number">-5</span></span><br><span class="line"><span class="number">4</span> Thread<span class="number">-2</span></span><br><span class="line"><span class="number">5</span> Thread<span class="number">-3</span></span><br><span class="line"></span><br><span class="line">Process finished <span class="keyword">with</span> exit code <span class="number">0</span></span><br></pre></td></tr></table></figure><p>接下来, 取消注释, 设置守护线程为<strong>true</strong>, 代码为:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="string">"__main__"</span> == __name__:</span><br><span class="line">    </span><br><span class="line">    start_time = time.time()</span><br><span class="line">    print(<span class="string">'主线程名称：'</span>, threading.current_thread().name)</span><br><span class="line"></span><br><span class="line">    iterNum = <span class="number">1</span></span><br><span class="line">    threadList = []</span><br><span class="line">    lock = threading.Lock()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 创建200个线程, 存入list</span></span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        thread_ = MyThread()</span><br><span class="line">        threadList.append(index)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 开启线程</span></span><br><span class="line">    <span class="keyword">for</span> thread_ <span class="keyword">in</span> ThreadList:</span><br><span class="line">        thread_.setDaemon(<span class="keyword">True</span>)  <span class="comment"># 设置线程守护</span></span><br><span class="line">        thread_.start()</span><br><span class="line">            </span><br><span class="line">    print(<span class="string">'主线程: '</span> + threading.current_thread().name + <span class="string">'结束'</span>)</span><br><span class="line">    print(<span class="string">'共计耗时：'</span>, time.time()-start_time)</span><br></pre></td></tr></table></figure><p>结果如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">主线程名称： MainThread</span><br><span class="line">主线程: MainThread结束</span><br><span class="line">共计耗时： <span class="number">0.0009665489196777344</span></span><br><span class="line"></span><br><span class="line">Process finished <span class="keyword">with</span> exit code <span class="number">0</span></span><br></pre></td></tr></table></figure><p>可以看出, 主线程运行结束, 由于守护线程的缘故, 直接将子线程杀死, 不再继续运行. 而部分条件下, 我们需要的结果是当主线程开启, 等待子线程运行结束后, 再结束主线程. 此时, 可以通过使用<strong>join</strong>()来实现, 代码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="string">"__main__"</span> == __name__:</span><br><span class="line">    </span><br><span class="line">    start_time = time.time()</span><br><span class="line">    print(<span class="string">'主线程名称：'</span>, threading.current_thread().name)</span><br><span class="line"></span><br><span class="line">    iterNum = <span class="number">1</span></span><br><span class="line">    threadList = []</span><br><span class="line">    lock = threading.Lock()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 创建200个线程, 存入list</span></span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        thread_ = MyThread()</span><br><span class="line">        threadList.append(index)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 开启线程</span></span><br><span class="line">    <span class="keyword">for</span> thread_ <span class="keyword">in</span> ThreadList:</span><br><span class="line">        thread_.setDaemon(<span class="keyword">True</span>)  <span class="comment"># 设置线程守护</span></span><br><span class="line">        thread_.start()</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">for</span> thread_ <span class="keyword">in</span> ThreadList:</span><br><span class="line">        thread_.join()</span><br><span class="line">    </span><br><span class="line">    print(<span class="string">'主线程: '</span> + threading.current_thread().name + <span class="string">'结束'</span>)</span><br><span class="line">    print(<span class="string">'共计耗时：'</span>, time.time()-start_time)</span><br></pre></td></tr></table></figure><p><strong>join</strong>()中存在一个<strong>timeout</strong>参数, 当设置守护线程时, 主线程等待<strong>timeout</strong>时间后再执行杀死子线程的操作. 当<strong>timeout</strong>不设定时, 表示等待子线程运行结束后, 再结束主线程. 上述代码运行结果如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">主线程名称： MainThread</span><br><span class="line"><span class="number">1</span> Thread<span class="number">-5</span></span><br><span class="line"><span class="number">2</span> Thread<span class="number">-2</span></span><br><span class="line"><span class="number">3</span> Thread<span class="number">-3</span></span><br><span class="line"><span class="number">4</span> Thread<span class="number">-1</span></span><br><span class="line"><span class="number">5</span> Thread<span class="number">-4</span></span><br><span class="line">主线程: MainThread结束</span><br><span class="line">共计耗时： <span class="number">1.006718397140503</span></span><br><span class="line"></span><br><span class="line">Process finished <span class="keyword">with</span> exit code <span class="number">0</span></span><br></pre></td></tr></table></figure><p>可以看出, 主线程以及计时均等待子线程结束后才开始实现. 当设定<strong>timeout</strong>时, 以下述两种情况为例:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设定 timeout = 0, 则5个子线程共计等待 0 * 5 = 0s, 即主线程不等待直接杀死子线程.</span></span><br><span class="line"><span class="keyword">for</span> thread_ <span class="keyword">in</span> ThreadList:</span><br><span class="line">    thread_.join(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">主线程名称： MainThread</span><br><span class="line">主线程: MainThread结束</span><br><span class="line">共计耗时： <span class="number">0.005353212356567383</span></span><br><span class="line"></span><br><span class="line">Process finished <span class="keyword">with</span> exit code <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设定 timeout = 0.2, 则5个子线程共计等待 0.2 * 5 = 1s, 主线程等待1s后杀死子线程.</span></span><br><span class="line"><span class="keyword">for</span> thread_ <span class="keyword">in</span> ThreadList:</span><br><span class="line">    thread_.join(<span class="number">0.2</span>)</span><br><span class="line"></span><br><span class="line">主线程名称： MainThread</span><br><span class="line"><span class="number">1</span> Thread<span class="number">-3</span></span><br><span class="line"><span class="number">2</span> Thread<span class="number">-1</span></span><br><span class="line"><span class="number">3</span> Thread<span class="number">-5</span></span><br><span class="line">主线程: MainThread结束</span><br><span class="line">共计耗时： <span class="number">1.0059242248535156</span></span><br><span class="line"></span><br><span class="line">Process finished <span class="keyword">with</span> exit code <span class="number">0</span></span><br></pre></td></tr></table></figure><p>可以看出, 当<strong>timeout</strong>设定为0.2s时, 有三个子线程运行结束, 仍有两个没来得及运行即被杀死.</p><h3 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h3><p>​    相对于多线程来说, 多进程操作中, 每一个子进程会作为真正独立的程序运行. 多线程运行过程中, 一个线程异常将导致整个程序故障. 而多进程中, 一个子进程异常基本不会影响其他进程的运行, 因而具有一定的稳定性, 但也较难以调试和控制. 此外, 多进程间的数据传递无法通过设置全局变量实现, 必须通过其专有的队列, 管道或共享内存的方式实现.</p><p>导入环境</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br></pre></td></tr></table></figure><p>为防止由于多个子进程导致的系统假死, 在主函数的最开始, 添加如下语句:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">multiprocessing.freeze_support()</span><br></pre></td></tr></table></figure><p>启动子进程的几种方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方法1</span></span><br><span class="line">process1 = multiprocessing.Process(target=processFun1, args=(param,))</span><br><span class="line">process2 = multiprocessing.Process(target=processFun2, args=(param,))</span><br><span class="line"></span><br><span class="line">process1.start()</span><br><span class="line">process2.start()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法2:</span></span><br><span class="line">pool = multiprocessing.Pool(processes=<span class="number">2</span>)  <span class="comment"># 创建进程池, 参数可缺省</span></span><br><span class="line"></span><br><span class="line">pool.apply_async(processFun1, (param, ))</span><br><span class="line">pool.apply_async(processFun2, (param, ))</span><br><span class="line"></span><br><span class="line">pool.close() <span class="comment"># 关闭进程池，表示不能在往进程池中添加进程</span></span><br><span class="line">pool.join()  <span class="comment"># 含义同多线程join()，必须在close()之后调用</span></span><br></pre></td></tr></table></figure><p>进程间数据共享支持queue, pipi, value和array. 但是python提供的更高层次的封装, 在我觉得使用起来更加方便, 而这些高级接口的调用, 可通过multiprocessing.Manager()方便的进行调用.</p><p>multiprocessing.Manager()支持list, dict, Namespace, Lock, RLock, Semaphore, BoundedSemaphore, Condition, Event, Queue, Value和Array.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">multiProcessManager = multiprocessing.Manager()</span><br><span class="line"><span class="comment"># list定义与调用示例</span></span><br><span class="line">mPMList = multiProcessManager.list([<span class="number">0</span>] * <span class="number">10</span>)</span><br><span class="line">callLlist = mPMList.value</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 多线程 </tag>
            
            <tag> 多进程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>原来是鸡汤啊~</title>
      <link href="/2018/06/20/%E5%8E%9F%E6%9D%A5%E6%98%AF%E9%B8%A1%E6%B1%A4%E5%95%8A/"/>
      <url>/2018/06/20/%E5%8E%9F%E6%9D%A5%E6%98%AF%E9%B8%A1%E6%B1%A4%E5%95%8A/</url>
      <content type="html"><![CDATA[<hr><p>“我不去想是否能够成功, 既然选择了远方, 便只顾风雨兼程”.</p><p>——汪国真</p><hr><p> “当生活很着急地步入正轨, 然后拿做完事情之余和空闲时间来看点什么的时候, 也是比无所事事玩手机的时候来得真开心”.</p><p>——刘佳楠</p><hr><p>“要谨记美言不可信, 要善于识别过眼烟云. 不要轻信唯一正确, 不能执着于左右两端, 要做到通而不痛, 远离烦恼, 创新永远”.</p><p>——钱旭红</p>]]></content>
      
      <categories>
          
          <category> 鸡汤 </category>
          
      </categories>
      
      
    </entry>
    
  
  
</search>
